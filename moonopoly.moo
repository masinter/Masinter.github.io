@dump moo
@chmod #87868."help" r
;;#87868.("help") = #87868
@chmod #87868."tasks" r
;;#87868.("tasks") = {}
@chmod #87868."state" r
;;#87868.("state") = ""
@chmod #87868."history" r
;;#87868.("history") = {{#125316, "moved from", "Electric Company", "forward 4
spaces to St. James Place"}, {#125316, "rolled", 2, "and", 2, "-- Doubles!"},
{#125316, "moved from", "Baltic Avenue", "forward 9 spaces to Electric
Company"}, {#125316, "rolled", 3, "and", 6}, {#125316, "moved from", "Short
Line Railroad", "forward 8 spaces to Baltic Avenue"}, {#125316, "rolled", 4,
"and", 4, "-- Doubles!"}, {#125316, "moved from", "Pacific Avenue", "forward 4
spaces to Short Line Railroad"}, {#125316, "rolled", 1, "and", 3}, {#125316,
"moved from", "Water Works", "forward 3 spaces to Pacific Avenue"}, {#125316,
"rolled", 2, "and", 1}, {#125316, "moved from", "Indiana Avenue", "forward 5
spaces to Water Works"}, {#125316, "rolled", 4, "and", 1}, {#125316, "moved
from", "St. James Place", "forward 7 spaces to Indiana Avenue"}, {#125316,
"rolled", 3, "and", 4}, {#125316, "bought", "St. James Place", "for", "$180"},
{#125316, "moved from", "Reading Railroad", "forward 11 spaces to St. James
Place"}, {#125316, "rolled", 5, "and", 6}, {#5704, "collected", "$25"},
{#125316, "paid", "$25"}, {#125316, "moved from", "Go", "forward 5 spaces to
Reading Railroad"}, {#125316, "rolled", 3, "and", 2}, {#125316, "collected",
"$1500"}, {#125316, "rolled", 4, "and", 6}, {#125316, "started playing"},
{#125338, "left the game"}, {#125338, "quit"}, {#125338, "quit"}, {#125338,
"moved from", "Center", "directly to Go"}, {#125338, "quit"}, {#5704, "left the
game"}, {#5704, "moved from", "2nd Community Chest", "directly to North
Carolina Avenue"}, {#5704, "collected", "$200"}, {#5704, "picked", "'From sale
of st...'", "from", "Community Chest"}, {#5704, "moved from", "St. Charles
Place", "forward 6 spaces to 2nd Community Chest"}, {#5704, "rolled", 3, "and",
3, "-- Doubles!"}, {#5704, "bought", "St. Charles Place", "for", "$140"},
{#5704, "moved from", "Reading Railroad", "forward 6 spaces to St. Charles
Place"}, {#5704, "rolled", 4, "and", 2}, {#5704, "bought", "Reading Railroad",
"for", "$200"}, {#5704, "collected", "$200"}, {#5704, "moved from", "Chance",
"to Reading Railroad"}, {#5704, "picked", "'Advance to the ...'", "from",
"Chance"}, {#5704, "collected", "$200"}}
@chmod #87868."riding" r
;;#87868.("riding") = {0, 4, 0}
@chmod #87868."tokens" r
;;#87868.("tokens") = {{"top hat", "racing car", "thimble", "boat", "doggie",
"horse", "shoe", "cannon", "iron", "wheelbarrow", "broomstick"}, {{"wearing a",
"tips %p %t"}, {"driving a", "honks %p horn"}, {"riding in a", "turns in %p
%t"}, {"sailing a", "tacks %p %t"}, {"leading a", "barks"}, {"racing a", "reins
%p %t"}, {"wearing a", "taps %p %t"}, {"firing a", "fires %p %t"}, {"steaming
an", "flattens with %p %t"}, {"pushing a", "overturns %p %t"}, {"floating on
a", "sweeps with %p %t"}}}
@chmod #87868."playerhas" r
;;#87868.("playerhas") = {0}
@chmod #87868."playerlocs" r
;;#87868.("playerlocs") = {"Center", "St. James Place", "Center"}
@chmod #87868."players" r
;;#87868.("players") = {#125397, #125316, #81176}
@chmod #87868."die" r
;;#87868.("die") = {{"   ", " o ", "   "}, {"o  ", "   ", "  o"}, {"o  ", " o
", "  o"}, {"o o", "   ", "o o"}, {"o o", " o ", "o o"}, {"o o", "o o", "o o"}}
@chmod #87868."requests" r
;;#87868.("requests") = {"Make l*ook look at property", "", "? Notify other
players when monopoly acquired", "Have 'status' group properties by color",
"stat <color> -- who owns what of that color?", "", "Add stuff for players to
have tokens", "pick <token>", "  top-hat racing-car thimble boat doggie
horserider shoe canon iron wheelbarrow", "  Sitting in a top-hat; riding a
racing car;", "  in a thimble; on a boat; riding a doggie;", "  next to a
horserider", "", "Player order: In status, say 'joe last rolled 2 and 5, mary's
turn now' or 'joe last", "rolled 2 and 2, joe goes again'", "", "stat order
shows who's turn it is now and who's next?", "", "random messages for 'user
picks up and shakes them' for variety"}
@chmod #87868."jailfree" r
;;#87868.("jailfree") = #-1
@chmod #87868."railroads" r
;;#87868.("railroads") = {6, 16, 26, 36}
@chmod #87868."utilities" r
;;#87868.("utilities") = {13, 29}
@chmod #87868."last_roll" r
;;#87868.("last_roll") = {2, 2, #125316}
@chmod #87868."color" r
;;#87868.("color") = {"", "purple", "", "purple", "", "", "light blue", "",
"light blue", "light blue", "", "light purple", "", "light purple", "light
purple", "", "orange", "", "orange", "orange", "", "red", "", "red", "red", "",
"yellow", "yellow", "", "yellow", "", "green", "green", "", "green", "", "",
"dark blue", "", "dark blue", "", ""}
@chmod #87868."mortgaged" r
;;#87868.("mortgaged") = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
@chmod #87868."features" r
;;#87868.("features") = {"a large arrow and the word GO printed in orange
here", "", "a blue chest and the words 'FOLLOW INSTRUCTIONS ON TOP CARD' here",
"", "the words 'Pay 10% or $200'", "a black choo-choo", "", "a large orange
question mark", "", "", "a cartoon figure in jail nearby", "", "a yellow
light-bulb", "", "", "a black choo-choo", "", "a blue chest and the words
'FOLLOW INSTRUCTIONS ON TOP CARD' here", "", "", "a large red car", "", "a
large blue question mark", "", "", "a black choo-choo", "", "", "a water
faucet", "", "a policeman holding up a finger", "", "", "a blue chest and the
words 'FOLLOW INSTRUCTIONS ON TOP CARD' here", "", "a black choo-choo", "a
large orange question mark", "", "a diamond ring and the words 'PAY $75.00'
here", "", "metal bars all around", "a reminder to type 'rules' for more
information"}
@chmod #87868."map_places" r
;;#87868.("map_places") = {{44, 41, 37, 33, 29, 25, 21, 17, 13, 9, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 9, 13, 17, 21, 25, 29, 33, 37, 41, 44, 44, 44, 44, 44, 44,
44, 44, 44, 44, 2, 25, 22}, {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 21,
19, 17, 15, 13, 11, 9, 7, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 7, 9, 11, 13,
15, 17, 19, 21, 23, 17, 9}}
@chmod #87868."map" r
;;#87868.("map") = {"+-----+---+---+---+---+---+---+---+---+---+-----+", "|PARK
|Ken|CHA|Ind|Ill|B&O|Atl|Ven|Wat|Mar|>JAIL|", "|     |   |   |   |   |   |   |
|   |   |     |", "+-----+---+---+---+---+---+---+---+---+---+-----+", "|New  |
|  Pac|", "+-----+                                   +-----+", "|Ten  |
|  Nor|", "+-----+                                   +-----+", "|CCH  |
|  CCH|", "+-----+                                   +-----+", "|StJ  |
|  Pen|", "+-----+                             tm    +-----+", "|Prr  |    M  O
O  N  O  P  O  L  Y      |  Sho|", "+-----+
+-----+", "|Vir  |                                   |  CHA|", "+-----+
+-----+", "|Sta  |                                   |  Par|", "+-----+
+-----+", "|Ele  |                                   |  LUX|", "+-----+
+-----+", "|StC  |                                   |  Brd|",
"+-----+---+---+---+---+---+---+---+---+---+-----+", "|     |   |   |   |   |
|   |   |   |   |   GO|", "|JAIL |Con|Ver|CHA|Ori|Rea|TAX|Bal|CCH|Med| <-- |",
"+-----+---+---+---+---+---+---+---+---+---+-----+"}
@chmod #87868."rules" r
;;#87868.("rules") = {{"rules moonopoly here", "", "MOOnopoly(tm) is
text-virtual reality version of the board game of", "similar name. You play the
game by landing on the board, and moving", "yourself around the square. Looking
about, you will see deeds, houses,", "hotels, as well as the various tokens.
Extensive help is available.", "", "The MOOnopoly board doesn't enforce the
rules or automatically play", "(buy or sell property).  This leaves some room
for negotiation, and", "cheating, too, if you can get away with it.", "", "For
more help, type 'rules <category>' for any of the following:", " summary
status         miscellaneous", " movement     money          property", "
houses       mortgage       cards", " jail         free-parking   income-tax",
" building-shortage           tokens", " leaving "}, {"summary verbs", " roll",
" move/go/advance [<place> | <n> | out | nearest [ r*ailroad | u*tility ]]", "
done", " pay/collect [<amount>]", " pay [<amount> to <player> | 10% ]", "
buy/sell/mortgage/unm*ortgage [<place>] [for <n>]", " tr*ansfer [ <place> |
card ]  to <player>", " pick/shuffle [<deck>]", " build/return [ <n> | hotel ]
[on <place>]", " stat*us [ <player> | roll | unowned | <color> | rail* | util*
| token ]", " history [<n>]", " d*eed <place>", " l*ook dice | <place> |
<thing>", " map ", " play [<token>]", " ride [<token>]", " quit/concede", "
exit", " reset", " no", "<place> is here or a place name. Watch out that
abbreviations", "choose the first property that match: St = St Charles Place"},
{"movement go roll advance", "roll                           Roll the dice.",
"move/go                        Roll and move the amount shown.", "no
Grab the dice if someone else rolls out of order.", "move <number>
Go forward (negative numbers go backward.)", "go to <place>                  Go
directly to the place.", "go out                         Get out of jail.",
"advance to <place>             Go forward to place; tell whether GO is
passed.", "advance to nearest r*ailroad   Just like it says.", "advance to
nearest u*tility", "done                           Tell other players you're
done with your turn.",
"================================================================", "THE
PLAY...", "  \"If a player throws doubles he moves as usual the sum of the
two", "dice and is subject to any privileges or penalties pertaining to the",
"space on which he lands. Retaining the dice, he throws again and moves", "his
token as before. If a player throws doubles three times in", "succession, he
moves immediately to the space marked 'In Jail'.\""}, {"money pay collect
rent", "collect <n>               Collect money from bank.", "collect
Collect $200.", "pay <n>                   Pay money to bank.", "pay <n> to
<player>       Give money to another player", "pay [rent]                 Pay
the amount of rent due, if any, to the", "                           owner of
your current space.", "pay 10%                   For use on Income Tax: pay 10%
of net worth.", "rent <place>              Show what rent is due on <place>."},
{"mortgage unmortgage", "mortgage [<place>] [for <n>]    <place> defaults to
your current location.", "unm*ortgage [<place>] [for <n>]", "", "You may only
mortgage property if it is unimproved, and must return", "any houses or hotels.
The mortgage value of a property is listed", "on its deed; to unmortgage a
property, you must pay 10% over the mortgage", "value."}, {"property buy sell
transfer", "buy [<place>] [for <n>]   Buy from the bank.", "sell[<place>] [for
<n>]   Sell to the bank.", "    <place> defaults to your current location.", "
The price is computed, but you can override it.", "", "tr*ansfer <place> to
<player>", "    To sell property between players, the seller transfers the", "
property to the buyer, and the buyer pays the seller the purchase", "    price.
You cannot transfer property with improvements.", "", "",
"================================================================", "BUYING
PROPERTY...", "   \"Whenever a player lands on an unowned property he may buy
that", "property from the Bank at its printed price....  If he does not wish",
"to buy the property it is sold at auction by to the highest bidder.", "The
buyer pays to the Bank the amount of the bid in cash... Any", "player,
including the one who declined the option of buying it at the", "printed price,
may bid.  Bidding may start at any price.", "", "SELLING PROPERTY...", "
Unimproved properties, railroads and utilities (but not ", "buildings) may be
sold to any player as a private transaction ", "for any amount that the owner
can get. However, no property can ", "be sold to another player if buildings
are standing on any ", "properties of that color-group. Any buildings so
located must ", "be returned to the Bank before the owner can sell any property
", "of that color-group.\""}, {"jail", "go out                  Get out of
jail", "return card             Return 'Get Out Of Jail Free' card", "transfer
card to <player>", "                        Give 'Get Out Of Jail Free' card to
another player.", "", "   \"A player gets out of Jail by... (1) throwing
doubles on any", "of his next three turns. (If he succeeds in doing this he ",
"immediately moves forward the number of spaces shown by his ", "doubles throw.
Even though he has thrown doubles he *does not* ", "take another turn.); (2)
using the 'Get Out of Jail Free' card ", "if he has it; (3) purchasing the 'Get
Out of Jail Free' card ", "from another player and playing it; (4) paying a
fine of $50 ", "before he rolls the dice on either of his next two turns.", "
If the player does not throw doubles by his third turn he ", "*must pay* the
$50 fine. He then gets out of Jail and immediately ", "move forward the number
of spaces shown by his throw.", "   Even though he is in Jail, a player may buy
or sell property, ", "buy or sell houses and hotels and collect rents.\""},
{"houses hotels build return", "build [<built>] [on <place>]", "
Build any number of houses, or a hotel. Defaults", "             to building 1
house on current space.", "", "return [<built>] [on <place>]", "
Return houses/hotel to bank, for half original price.", "", "There are only 12
hotels and 32 houses; see 'building shortage' ", "for details.",
"================================================================", "   \"When
a player owns all the properties in a color-group he may", "buy houses from the
Bank and erect them on those properties.", "   If he buys one house, he may put
it on any one of those ", "properties. The next house he buys must be erected
on one of the ", "unimproved properties of this or any other complete
color-group ", "he may own.", "   The price he must pay the Bank for each house
is shown on his ", "Title Deed card for the property on which he erects the
house.", "   The owner can still collect double rent from an opponent who ",
"lands on the unimproved properties of his complete color-group.", "
Following the above rules, a player may buy and erect at any ", "time as many
houses as his judgement and financial standing will ", "allow. *But he must
build evenly* (i.e.: he cannot erect more ", "than one house on any one
property of any color-group until he ", "has built one house on every property
of that group. He may then ", "begin on the second row of houses, and so on, up
to a limit of ", "four houses to a property. For example, he cannot build three
", "houses on one property if he has only one house on another ", "property of
that group.)", "   As a player builds evenly, he must also break down evenly if
", "he sells houses back to the Bank.\""}, {"building-shortage",
"================================================================", "BUILDING
SHORTAGE", "\"   When the Bank has no houses to sell, players wishing to build
", "must wait for some player to turn back or to sell his houses to ", "the
Bank before building. If there are a limited number of houses ", "and hotels
available, and two or more players wish to buy more ", "than the Bank has, the
houses or hotels must be sold at auction ", "to the highest bidder.\"", "",
"There are only 12 hotels and 32 houses in the set.", "[*NB*] The 'auction'
facility is not currently implemented."}, {"cards community-chest chance",
"pick [<deck>]               Pick a card from the deck.", "shuffle [<deck>]
Shuffle community chest or chance cards (or both).", "", "return card
Return Get Out Of Jail Free card to deck.", "tr*ansfer card to <player>  Give
card to another player.  ",
"================================================================", "  \"The
'Get Out of Jail Free' card is held until used and then", "returned to the
deck. If the player who draws it does not wish to use", "it he may sell it, at
any time, to another player at a price agreeable", "to both.\"", "", "[*NB*] To
sell a card to another player, the seller transfers the", "card to the buyer,
who pays the sales price to the seller."}, {"status query worth map history
dice deed", "rent [<place>]            What rent is due on <place> (defaults to
'here')", "stat                      who owns what", "stat <player>
Subset, for a particular player. ('stat me')", "stat [<color> | util | railroad
]", "stat token                Who is playing as what token?", "stat unowned
What properties aren't owned?", "look                      Look around, tells
you who is where.", "look dice                 Who last rolled what?", "look
<place>              See what's on a given square", "d*eed <place>
Show you the deed to a place", "rules <topic>             How you get these
messages.", "worth                     Show what you're worth (for tax
purposes).", "history [<n>]             Show <n> recent events, defaults to 10.
", "map                       Show a map of the game."}, {"tokens", "ride
<token>          Select a token to play as.", "play <token>              Start
playing, too.", "stat tokens               Show which tokens are used & free.",
"", "Players can select a token, which changes their 'look' in the game."},
{"leaving quit exit leave out concede", "exit                    Leave the
board temporarily.", "concede                 Stop playing the game; return all
property to bank.", "quit                    Concede and exit.", "",
"Teleporting out, or leaving in a manner other than 'exit' will remove", "the
player from the game and returns all property, if they don't return", "within
30 seconds and remain."}, {"miscellaneous play reset no done", "play [<token>]
Start playing the game:", "                           pick the token, collect
$1500, move to go,", "                           roll to see who goes
first...", "reset game                Reset the entire game.", "no
Stop an pending dice-roll or game reset.", "done                      Emote a
message that your turn is done.", "yell                      Speak loudly
enough that those outside can hear.", "look out                  See what's
happening outside.", ""}, {"free-parking", "FREE PARKING...", "   A player
landing on this space does not receive any money, ", "property or reward of any
kind. This is just a 'free' resting place.", "Many players are used to house
rules where free parking keeps a jackpot", "of all taxes and fees. This game
does not support it."}, {"income-tax", "Upon landing on income tax, the player
should quickly, without taking", "time to figure his net worth, choose:", "
pay $200", "   pay 10%", "",
"================================================================", "INCOME
TAX", "   \"When a player lands on 'Income Tax' he has two options: he may",
"estimate his tax at $200 and pay the Bank, or he may pay 10% of his", "total
worth to the Bank. His total worth is all his cash on hand,", "printed prices
of mortgaged and unmortgaged properties and cost price", "of all buildings he
owns.", "   The player must decide which option he will take *before* he adds",
"up his total worth.\""}}
@chmod #87868."chance_name" r
;;#87868.("chance_name") = "Chance"
@chmod #87868."chest_name" r
;;#87868.("chest_name") = "Community Chest"
@chmod #87868."chance_marker" r
;;#87868.("chance_marker") = 4
@chmod #87868."chest_marker" r
;;#87868.("chest_marker") = 3
@chmod #87868."chance" r
;;#87868.("chance") = {"GO DIRECTLY TO JAIL; do not pass GO, do not collect
$200.", "Take a walk on the board walk: advance token to Boardwalk.", "Advance
to the nearest Railroad and pay owner Twice the Rental to which he is otherwise
entitled. If Railroad is unowned, you may buy it from the Bank.", "Go back 3
spaces.", "Bank pays you dividend of $50.", "Advance token to nearest Utility.
If UNOWNED, you may buy it from bank. If OWNED, throw dice and pay owner a
total ten times the amount thrown.", "Your building and loan matures: collect
$150.", "GET OUT OF JAIL FREE. This card may be kept until needed or sold.",
"Advance to Illinois Ave.", "Take a ride on the Reading. If you pass GO collect
$200.", "Make general repairs on all your property: for each house pay $25, for
each hotel $100.", "Advance to St. Charles Place. If you pass GO, collect
$200.", "You have been elected Chairman of the Board: pay each player $50.",
"Advance to the nearest Railroad and pay owner Twice the Rental to which he is
otherwise entitled. If Railroad is unowned, you may buy it from the Bank.",
"Advance to GO (collect $200).", "Pay poor tax of $15."}
@chmod #87868."owners" r
;;#87868.("owners") = {#-1, #-1, #-1, #5704, #-1, #5704, #-1, #-1, #5704,
#5704, #-1, #5704, #5704, #-1, #-1, #-1, #125316, #-1, #-1, #-1, #-1, #-1, #-1,
#-1, #-1, #-1, #-1, #-1, #-1, #-1, #-1, #-1, #5704, #-1, #-1, #-1, #-1, #-1,
#-1, #5704, #-1, #-1}
@chmod #87868."houses" r
;;#87868.("houses") = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
@chmod #87868."housing" r
;;#87868.("housing") = {0, {50, 2, 10, 30, 90, 160, 250}, 0, {50, 4, 20, 60,
180, 320, 450}, 0, 0, {50, 6, 30, 90, 270, 400, 550}, 0, {50, 6, 30, 90, 270,
400, 550}, {50, 8, 40, 100, 300, 450, 600}, 0, {100, 10, 50, 150, 450, 626,
750}, 0, {100, 10, 50, 150, 450, 626, 750}, {100, 12, 60, 180, 500, 700, 900},
0, {100, 14, 70, 200, 550, 750, 950}, 0, {100, 14, 70, 200, 550, 750, 950},
{100, 16, 80, 220, 600, 800, 1000}, 0, {100, 18, 90, 250, 700, 875, 1050}, 0,
{100, 18, 90, 250, 700, 875, 1050}, {150, 20, 100, 300, 750, 925, 1100}, 0,
{150, 22, 110, 330, 800, 975, 1150}, {150, 22, 110, 330, 800, 975, 1150}, 0,
{150, 24, 120, 360, 850, 1025, 1200}, 0, {200, 26, 130, 390, 900, 1100, 1275},
{200, 26, 130, 390, 900, 1100, 1275}, 0, {200, 28, 150, 450, 1000, 1200, 1400},
0, 0, {200, 35, 175, 500, 1100, 1300, 1500}, 0, {200, 50, 200, 600, 1400, 1700,
2000}, 0, 0}
@chmod #87868."price" r
;;#87868.("price") = {0, 60, 0, 60, 0, 200, 100, 0, 100, 120, 0, 140, 180, 140,
160, 200, 180, 0, 180, 200, 0, 220, 0, 220, 240, 200, 260, 260, 180, 280, 0,
300, 300, 0, 320, 200, 0, 350, 0, 400, 0, 0}
@chmod #87868."chest" r
;;#87868.("chest") = {"You inherit $100.", "From sale of stock you get $45.",
"Doctor's fee: pay $50.", "Life insurance matures: collect $100.", "Receive for
services $25.", "Xmas fund matures: collect $100.", "GO TO JAIL. Go Directly to
Jail; do not pass GO, do not collect $200.", "Advance to GO (collect $200).",
"GET OUT OF JAIL FREE. This card may be kept until needed or sold.", "You are
assessed for street repairs: $40 per house, $115 per hotel.", "Pay school tax
of $150.", "Grand Opera Opening: collect $50 from every player for opening
night seats.", "Income tax refund: collect $20.", "Bank error in your favor:
collect $200.", "Pay hospital $100.", "You have won Second Prize in a beauty
contest: collect $10."}
@chmod #87868."has" r
;;#87868.("has") = {{#125316, 1295}, {#5704, 725}}
@chmod #87868."listening" r
;;#87868.("listening") = 1
@chmod #87868."places" r
;;#87868.("places") = {"Go", "Mediterranean Avenue", "Community Chest", "Baltic
Avenue", "Income Tax", "Reading Railroad", "Oriental Avenue", "Chance",
"Vermont Avenue", "Connecticut Avenue", "Jail--Just Visiting", "St. Charles
Place", "Electric Company", "States Avenue", "Virginia Avenue", "Pennsylvania
Railroad", "St. James Place", "2nd Community Chest", "Tennessee Avenue", "New
York Avenue", "Free Parking", "Kentucky Avenue", "2nd Chance", "Indiana
Avenue", "Illinois Avenue", "B&O Railroad", "Atlantic Avenue", "Ventnor
Avenue", "Water Works", "Marvin Gardens", "Go to Jail", "Pacific Avenue",
"North Carolina Avenue", "3rd Community Chest", "Pennsylvania Avenue", "Short
Line Railroad", "3rd Chance", "Park Place", "Luxury Tax", "Boardwalk", "Jail",
"Center"}
@chmod #87868."initial_place" r
;;#87868.("initial_place") = "Center"
;;#87868.("help_msg") = {"MOOnopoly(tm) is text-virtual reality version of the
board game of", "similar name. You play the game by landing on the board, and
moving", "yourself around the square. Looking about, you will see deeds,
houses,", "hotels, as well as the various tokens. Extensive help is available,
please type 'rules' to see the list of the categories of what help is
available.", "History of MOOnopoly(tm). MOOnopoly was originally coded by gru
(#122) back in 1992. Around the middle of 1997, gru (who was at the time, over
quota) offered the board to pensette (#84567) so that she could modify it to
make it run again under 1.8, and maintain it thereafter.", "As of this date,
this object has not been reimbursed by the ARB.", "Availability. MOOnopoly is
available in the dining room only, and is not fertile.  It is not to be ported
to another MOO without permission of gru (original coder) and/or pensette
(maintainer).", "                  And now the fun! How to play. Go to the
board.", "play [<token>]. This will pick the token, collect $1500, move to go,
etc.", "If there's a group there, ask to play. At this time you may also 'reset
game'.", "If the room is cluttered with ghosts, you may 'dust' and clear them
out. *This is a temporary modification."}
"#87868.("visible_props") => E_PERM (Permission denied)
"#87868.("move_ok") => E_PERM (Permission denied)
"#87868.("silent_actions") => E_PERM (Permission denied)
"#87868.("accept_key") => E_PERM (Permission denied)
;;#87868.("inside_description") = "This is the interior of the generic portable
room."
"#87868.("entrances") => E_PERM (Permission denied)
"#87868.("exits") => E_PERM (Permission denied)
"#87868.("key") => E_PERM (Permission denied)
;;#87868.("aliases") = {"Moonopoly Board"}
;;#87868.("description") = "A Moonopoly(TM) board, LambdaMoo Electronic Edition
of 1991. When playing it, type 'rules' to see how to run it. MOOnopoly
Copyright (c) 1991, Grump@LambdaMoo."
;;#87868.("object_size") = {81632, 1697703032}

@args #87868:"get_floor get_space" this none this
@program #87868:get_floor
if (ind = args[1] in this.players)
  return this.playerlocs[ind];
endif
return E_NONE;
.

@args #87868:"look_self" this none this
@program #87868:look_self
player:tell(this:title());
if (!(args && args[1]))
  player:tell_lines(this:description());
endif
if (!(player in (contents = this.contents)))
  return this:map();
endif
this:showwhere(1, player);
.

@args #87868:"set_floor set_space" this none this
@program #87868:set_floor
if (caller_perms() != this.owner)
  player:tell("Permission denied.");
  return;
endif
who = args[1];
where = args[2];
if ((typeof(who) != OBJ) || (!(where in this.places)))
  player:tell("Can't set ", who, " to be in ", where, ".");
  return;
endif
if (i = who in this.players)
  this.playerlocs[i] = where;
else
  this.players = {@this.players, who};
  this.playerlocs = {@this.playerlocs, where};
  this.riding = {@this.riding, 0};
endif
.

@args #87868:"exitfunc" this none this
@program #87868:exitfunc
what = args[1];
"leave game if not going to an editor and via a verb not defined on this";
if (!$object_utils:isa(what.location, $generic_editor))
  for x in (callers())
    if ((x[1] == this) && (x[2] in {"exit"}))
      return pass(@args);
    endif
  endfor
  fork (60)
    if (!(what in this.contents))
      "Didn't come back.";
      if (this:remove_player(what))
        this:remember(what, "left the game");
        this:announce_all_but({what}, what:title(), " left abruptly, dropping
out of the game.");
        what:tell("You left ", this.name, " abruptly, and drop out of the
game.");
      endif
    endif
  endfork
endif
return pass(@args);
.

@args #87868:"enterfunc" this none this
@program #87868:enterfunc
object = args[1];
if (ERR == typeof(this:get_floor(object)))
  floor = this:guess_floor();
  if (floor == E_NONE)
    floor = this.initial_place;
  endif
  this:set_floor(args[1], floor);
  if ($object_utils:has_property(object, "gender"))
    fork (0)
      this:announce_all_but({object}, object:title(), " landed on ", floor,
".");
    endfork
  endif
endif
pass(@args);
.

@args #87868:"announce" this none this
@program #87868:announce
floor = this:get_space(caller);
if (!floor)
  pass(@args);
else
  this:floor_announce(floor, {player}, @args);
endif
.

@args #87868:"announce_all" this none this
@program #87868:announce_all
if ((caller == this) || (ERR == typeof(floor = this:get_floor(caller))))
  pass(@args);
else
  this:floor_announce(floor, {}, @args);
endif
.

@args #87868:"announce_all_but" this none this
@program #87868:announce_all_but
floor = this:get_floor(caller);
if (!floor)
  return pass(@args);
endif
this:floor_announce(floor, @args);
.

@args #87868:"floor_announce" this none this
@program #87868:floor_announce
this:clean();
floor = args[1];
omit = args[2];
text = args[3..length(args)];
for x in [1..length(this.players)]
  play = this.players[x];
  if (((play.location == this) && (this.playerlocs[x] == floor)) && (!(play in
omit)))
    play:tell(@text);
  endif
endfor
.

@args #87868:"say" any any any
@chmod #87868:say rxd
@program #87868:say
player:tell("You say, \"", argstr, "\"");
floor = this:get_floor(player) || "somewhere";
cnt = this.contents;
for x in (cnt)
  if (x != player)
    x:tell(player.name, " ", ((ind = x in this.players) &&
(this.playerlocs[ind] == floor)) ? "says" | ("says from " + floor), ", \"",
argstr, "\"");
  endif
endfor
.

@args #87868:"emote" any any any
@chmod #87868:emote rxd
@program #87868:emote
msg = player.name + (((argstr != "") && (argstr[1] == ":")) ?
argstr[2..length(argstr)] | (" " + argstr));
floor = this:get_floor(player) || "somewhere";
cnt = this.contents;
for x in (cnt)
  x:tell(((ind = x in this.players) && (this.playerlocs[ind] == floor)) ? "" |
(this:onroom(floor, 1) + ": "), msg);
endfor
.

@args #87868:"guess_floor" this none this
@program #87868:guess_floor
lst = listappend($list_utils:slice(callers()), player);
floor = E_NONE;
while (lst && ((!valid(lst[1])) || (typeof(floor = this:get_floor(lst[1])) ==
ERR)))
  lst = listdelete(lst, 1);
endwhile
return floor;
.

@args #87868:"go move advance" any any any
@chmod #87868:go rxd
@program #87868:go
oldfloor = this:get_floor(player);
oldind = oldfloor in this.places;
advance = verb == "advance";
if (!argstr)
  cnt = this:roll();
else
  cnt = tonum(argstr);
endif
if (cnt || (argstr == "0"))
  advance = cnt > 0;
  if (!oldind)
    player:tell("You don't seem to be anywhere on ", this.name, ".");
  elseif (oldind > 40)
    player:tell("You can't move that way from ", oldfloor, ".");
    return;
  elseif ((cnt > 12) || (cnt < -12))
    player:tell("You try to go ", cnt, " spaces, but decide it is too far, and
stay put.");
    return;
  endif
  new = this.places[(((oldind + cnt) + 39) % 40) + 1];
  announce = (cnt > 0) ? "forward " | "backward ";
  cnt = abs(cnt);
  announce = (((announce + tostr(cnt)) + " space") + ((cnt == 1) ? " to " | "s
to ")) + new;
elseif ((argstr == "out") && (oldfloor in {"Jail", "In Jail"}))
  new = "Jail--Just Visiting";
  announce = "out of Jail";
else
  where = argstr;
  if (index(where, "to ") == 1)
    where = where[4..length(where)];
  endif
  if (index(where, "nearest"))
    places = this.(index(where, "est r") ? "railroads" | "utilities");
    advance = 1;
    nearest = 0;
    for x in (places)
      if ((!nearest) && (x > oldind))
        nearest = x;
      endif
    endfor
    if (!nearest)
      nearest = places[1];
    endif
    where = this.places[nearest];
  endif
  if (!(new = this:find(where)))
    player:tell("I don't know how to go ", argstr);
    return;
  endif
  announce = (advance ? "to " | "directly to ") + new;
endif
player:tell("You ", verb, " ", announce, ".");
this:remember(player, "moved from", oldfloor, announce);
this:set_floor(player, new);
player:tell(new);
if (!($object_utils:has_property(player, "brief") && player.brief))
  player:tell_lines(this:description());
endif
others = setremove(this:get_contents(new), player);
this:tell_contents(others, this.ctype);
for x in (others)
  x:tell(this:ptitle(player), " comes ", announce, ".");
endfor
this:announce_all_but({player, @others}, this:ptitle(player), " ", (verb ==
"go") ? "goes " | (verb + "s "), announce, ".");
if ((advance && ((new in this.places) <= oldind)) && (oldind < 41))
  msg = (new == "Go") ? "landed on" | "passed";
  player:tell("You ", msg, " GO! Collect $200.");
  this:announce(player.name, " ", msg, " Go and should collect $200.");
endif
rent = this:rent_due(new, player);
if (rent[1])
  landlord = rent[2];
  msg = ((landlord.name + " $") + tostr(rent[1])) + " rent.";
  player:tell("You owe ", msg);
  this:announce_all_but({player, landlord}, player.name, " owes ", msg);
  landlord:tell(player.name, " owes you $", rent[1], " rent.");
endif
.

@args #87868:"r*oll" none none none
@chmod #87868:roll rxd
@program #87868:roll
if (this.tasks)
  player:tell("Sorry, the dice are busy.");
  return;
endif
msg = {"%N %<picks> up the dice and %<shakes> them...", "%n %<grunts> and
%<heaves> the dice into the air with great effort..."}[random(2)];
player:tell($string_utils:pronoun_sub(msg, $you));
this:announce_all_but({player}, $string_utils:pronoun_sub(msg, player));
this.tasks = {@this.tasks, task = {"%N %<grabs> the dice away!", task_id()}};
suspend(2);
this.tasks = setremove(this.tasks, task);
die1 = random(6);
die2 = random(6);
msg = ((((tostr(die1) + " and ") + tostr(die2)) + " for ") + tostr(die1 +
die2)) + ".";
if (die1 == die2)
  msg = msg + " Doubles!";
endif
player:tell("You roll ", msg);
this:announce_all_but({player}, player:title(), " rolls ", msg);
this.last_roll = {die1, die2, player};
this:remember(player, "rolled", die1, "and", die2, @(die1 == die2) ? {"--
Doubles!"} | {});
return die1 + die2;
.

@args #87868:"stat*us" any none none
@chmod #87868:status rxd
@program #87868:status
"this verb has not yet been fixed - 7/97, pensette";
aa = 0;
want = this;
this:clean();
if (dobjstr)
  if (index(dobjstr, "token") == 1)
    this:dostatus("token");
    return;
  elseif (dobjstr == "unowned")
    want = #-1;
  elseif (dobjstr == "roll")
    want = #-5;
  elseif (index(dobjstr, "rail") == 1)
    want = this.railroads;
  elseif (index(dobjstr, "util") == 1)
    want = this.utilities;
  elseif (dobjstr in this.color)
    want = dobjstr;
  elseif (!valid(want = this:find_player(dobjstr)))
    return;
  endif
endif
if (want == this)
  own = this.has;
else
  own = {};
  for x in (this.has)
    if (x[1] == want)
      own = listappend(own, x);
    endif
  endfor
endif
for x in [1..length(this.places)]
  if (this.price[x])
    owner = this.owners[x];
    if ((((owner == want) || (valid(owner) && (want == this))) ||
(this.color[x] == want)) || ((typeof(want) == LIST) && (x in want)))
      own = {@own, {owner, this.places[x]}};
    endif
  endif
endfor
if (valid(jf = this.jailfree))
  if (want in {this, jf})
    own = {@own, {jf, "Get out of Jail Free Card"}};
  endif
endif
own = $list_utils:sort_alist(own);
last = "nothing";
for x in (own)
  if (last == x[1])
    name = "              ";
  else
    name = $string_utils:left(valid(x[1]) ? x[1].name | "unowned", 14);
    last = x[1];
  endif
  if (typeof(owned = x[2]) == NUM)
    owned = "$" + tostr(owned);
  elseif (ind = owned in this.places)
    lst = {};
    if (c = this.color[ind])
      lst = {c};
    endif
    if (h = this.houses[ind])
      lst = {@lst, (h == 5) ? "hotel" | ((tostr(h) + " house") + ((h == 1) ? ""
| "s"))};
    endif
    if (m = this.mortgaged[ind])
      lst = {@lst, "mortgaged"};
    endif
    if (lst)
      owned = ((owned + " (") + $string_utils:from_list(lst, ", ")) + ")";
    endif
  endif
  aa = 1;
  player:tell(" ", name, owned);
endfor
if (!aa)
  player:tell((valid(want) && (want != this)) ? want:title() + ": " | "",
"Nothing owned.");
endif
.

@args #87868:"description" this none this
@program #87868:description
who = args ? args[1] | player;
if (who.location == this)
  floor = this:get_floor(who);
  desc = this:roomdesc(floor, player);
  return desc + " There are some enormous dice in the distance.";
else
  return pass();
endif
.

@args #87868:"play" any any any
@chmod #87868:play rxd
@program #87868:play
if (player.location == this)
  if (argstr && (!this:ride()))
    return;
  endif
  if ($list_utils:assoc(player, this.has) || (player in this.owners))
    if (!argstr)
      player:tell("You are already playing Monopoly.");
    endif
  else
    player:tell("You start playing Monopoly.");
    this:announce(player.name, " starts playing Monopoly.");
    this:remember(player, "started playing");
    if (this:get_floor(player) != "Go")
      this:set_floor(player, "Go");
      this:look_self(player.brief);
      this:announce(player.name, " moves to Go.");
    endif
    player:tell("You roll to see who will go first.");
    this:announce(player.name, " rolls to see who will go first.");
    this:roll();
    this:collect(player, 1500);
  endif
else
  player:tell("You have to be on ", this.name, " to play it!");
  this:enter();
endif
.

@args #87868:"buy sell mor*tgage unm*ortgage" any any any
@chmod #87868:buy rxd
@program #87868:buy
vb = verb;
if (!(where = this:find(dobjstr)))
  player:tell("Sorry, '", dobjstr, "' isn't a valid place name.");
  return;
endif
index = where in this.places;
if (!(price = this.price[index]))
  player:tell(where, " can't be bought or sold.");
  return;
endif
if (vb in {"buy", "sell"})
  if (!iobjstr)
    iobjstr = tonum(price);
  endif
elseif (index(vb, "unm"))
  vb = "unmortgage";
  if (!iobjstr)
    iobjstr = tonum((price * 11) / 20);
  endif
else
  vb = "mortgage";
  if (!iobjstr)
    iobjstr = tonum(price / 2);
  endif
endif
if ((!(n = tonum(iobjstr))) && (iobjstr != "0"))
  player:tell("Sorry, ", iobjstr, " is not a valid number.");
  return;
endif
owner = this.owners[index];
has = this.has;
playerhas = $list_utils:assoc(player, has) || {player, 0};
if (vb == "buy")
  if (owner == player)
    player:tell("You already own ", where, "!");
    return;
  elseif ((typeof(owner) == OBJ) && valid(owner))
    player:tell(owner:title(), " already owns ", where, "!");
    return;
  elseif (playerhas[2] < n)
    player:tell("You don't have $", n, "; you only have $", playerhas[2], "!");
    return;
  endif
  if (this.price[index] != n)
    player:tell("Note! The price of ", where, " is $", this.price[index], ",
not $", n, "!");
  endif
  this.has = {{player, playerhas[2] - n}, @setremove(has, playerhas)};
  this.owners[index] = player;
elseif (owner != player)
  "can't mortgage, unmortgage or sell if you don't own.";
  player:tell("You don't own ", where, "!");
  return;
elseif (this.houses[index])
  player:tell("Sorry, ", where, " still has ",
this:house_str(this.houses[index]), " on it!");
  return;
elseif (vb == "unmortgage")
  if (!this.mortgaged[index])
    player:tell(where, " isn't mortgaged!");
    return;
  endif
  this.has = {{player, playerhas[2] - n}, @setremove(has, playerhas)};
  this.mortgaged[index] = 0;
elseif (this.mortgaged[index])
  player:tell("Sorry, ", where, " is ", (vb == "mortgage") ? "already " | "",
"mortgaged!");
  return;
else
  this.has = {{player, playerhas[2] + n}, @setremove(has, playerhas)};
  if (vb == "mortgage")
    this.mortgaged[index] = 1;
  else
    this.owners[index] = #-1;
  endif
endif
player:tell("You ", vb, " ", where, " for $", iobjstr, ".");
this:remember(player, (vb == "buy") ? "bought" | ((vb == "sell") ? "sold" | (vb
+ "ed")), where, "for", "$" + tostr(iobjstr));
this:announce_all_but({player}, player:title(), " ", vb, "s ", where, " for $",
iobjstr, ".");
.

@args #87868:"collect pay" any any any
@chmod #87868:collect rxd
@program #87868:collect
if ((length(args) == 2) && (typeof(args[2]) == NUM))
  payer = args[1];
  amount = args[2];
elseif ((!dobjstr) || (dobjstr == "rent"))
  if (prepstr)
    player:tell("Sorry, I didn't understand that.");
    return;
  endif
  if (verb != "pay")
    if (dobjstr == "")
      amount = 200;
      payer = player;
    else
      player:tell("Sorry, you can't collect rent directly.");
      return 0;
    endif
  else
    rent = this:rent_due();
    if (rent[1] == 0)
      player:tell("Nothing due: ", rent[2], ".");
    else
      this:pay(player, rent[1]) && this:collect(rent[2], rent[1]);
    endif
    return 0;
  endif
elseif (prepstr)
  if (!valid(recip = this:find_player(iobjstr)))
    return;
  endif
  if (dobjstr[1] == "$")
    dobjstr = dobjstr[2..length(dobjstr)];
  endif
  if ((!(amount = tonum(dobjstr))) && (dobjstr != "0"))
    player:tell(dobjstr, " is not a valid number.");
    return 0;
  endif
  this:(verb)(player, amount) && this:((verb == "pay") ? "collect" |
"pay")(recip, amount);
  return;
elseif (dobjstr == "10%")
  payer = player;
  amount = this:worth() / 10;
else
  if (dobjstr[1] == "$")
    dobjstr = dobjstr[2..length(dobjstr)];
  endif
  if ((!(amount = tonum(dobjstr))) && (dobjstr != "0"))
    player:tell(dobjstr, " is not a valid number.");
    return 0;
  endif
  payer = player;
endif
has = this.has;
playerhas = $list_utils:assoc(payer, has) || {payer, 0};
if (verb == "pay")
  new = playerhas[2] - amount;
  if (new < 0)
    payer:tell("You don't have $", amount, "; you only have $", playerhas[2],
"!");
    return 0;
  endif
else
  new = playerhas[2] + amount;
endif
this.has = {{payer, new}, @setremove(has, playerhas)};
payer:tell("You ", verb, " $", amount, "; you now have $", new, ".");
this:remember(payer, (verb == "pay") ? "paid" | "collected", "$" +
tostr(amount));
this:announce_all_but({payer}, payer:title(), " ", verb, "s $", amount, ".");
return 1;
.

@args #87868:"rules about" any none none
@chmod #87868:rules rxd
@program #87868:rules
if (!(player in this.contents))
  dobjstr == "";
endif
for x in (this.rules)
  if ((!dobjstr) || index(x[1], dobjstr))
    player:tell_lines(listdelete(x, 1));
    return;
  endif
endfor
player:tell("Sorry, no rules for '", dobjstr, "' on ", this.name, ". Use '",
$string_utils:words(this.rules[1][1])[1], "' instead.");
.

@args #87868:"rent_due" this none this
@program #87868:rent_due
if (args)
  place = args[1];
  play = args[2];
else
  play = player;
  place = this:get_floor(player);
endif
if (!(index = place in this.places))
  return {0, "there is no such (?) place"};
endif
if (!this.price[index])
  return {0, "not a rental property"};
endif
owner = this.owners[index];
if ((typeof(owner) != OBJ) || (!valid(owner)))
  return {0, "space is not owned"};
endif
if (owner == play)
  return {0, "owned by the player"};
endif
if (this.mortgaged[index])
  return {0, "property is mortgaged"};
endif
minh = 9999;
maxh = 0;
if (rents = this.housing[index])
  all = 1;
  color = this.color[index];
  for i in [1..40]
    if (this.color[i] == color)
      if (this.owners[i] != owner)
        all = 0;
      else
        minh = min(minh, this.houses[i]);
        maxh = max(maxh, this.houses[i]);
      endif
    endif
  endfor
  houses = this.houses[index];
  if (all)
    if ((minh + 1) < maxh)
      return {0, ((("maximum number of houses on color (" + tostr(maxh)) + ")
more than one larger than minimum (") + tostr(minh)) + ")"};
    elseif (houses)
      return {rents[2 + houses], owner};
    else
      return {rents[2] * 2, owner};
    endif
  elseif (maxh > 0)
    return {0, "there are improvements but not all other properties of the same
color are owned"};
  else
    return {rents[2], owner};
  endif
elseif (index in this.railroads)
  cnt = 0;
  for x in (this.railroads)
    if (this.owners[x] == owner)
      cnt = cnt + 1;
    endif
  endfor
  return {{25, 50, 100, 200}[cnt], owner};
elseif (index in this.utilities)
  "utility";
  return {(this.last_roll[1] + this.last_roll[2]) * ((this.owners[13] ==
this.owners[29]) ? 10 | 4), owner};
else
  return 0;
endif
.

@args #87868:"build" any any any
@chmod #87868:build rxd
@program #87868:build
if (!(where = this:find(iobjstr)))
  player:tell("There doesn't seem to be any way to build on ", iobjstr, "?");
endif
index = where in this.places;
if (!this.color[index])
  player:tell("Sorry, you can't build on ", where, ".");
  this:announce(player.name, " tries to build on ", where, ".");
  return;
elseif (this.owners[index] != player)
  player:tell("Sorry, you don't own ", this.places[index], ".");
  return;
endif
houses = this.houses[index];
if (houses == 5)
  player:tell("Sorry, there's already a hotel here.");
  return;
elseif (dobjstr == "hotel")
  build = 5 - houses;
elseif (((dobjstr == "a house") || (dobjstr == "house")) || (dobjstr == ""))
  build = 1;
elseif (!(build = tonum(dobjstr)))
  player:tell("Sorry, I don't know how to build ", dobjstr, ".");
  return;
endif
if ((build + houses) > 5)
  player:tell("Sorry, that would result in ", build + houses, " houses!");
  return;
endif
cost = this.housing[index][1] * build;
has = this.has;
playerhas = $list_utils:assoc(player, has) || {player, 0};
if (playerhas[2] < cost)
  player:tell("You don't have $", cost, "; you only have $", playerhas[2],
"!");
  return;
endif
this.has = {{player, playerhas[2] - cost}, @setremove(has, playerhas)};
new = build + houses;
nh = listset(this.houses, build + houses, index);
houses = 0;
hotels = 0;
for x in (nh)
  if (x == 5)
    hotels = hotels + 1;
  else
    houses = houses + x;
  endif
endfor
if (houses > 32)
  player:tell("Sorry, the bank only has 32 houses.");
  return;
elseif (hotels > 12)
  player:tell("Sorry, the bank only has 12 hotels.");
  return;
endif
this.houses = nh;
this:remember(player, (verb == "build") ? "built" | "returned", build,
"house(s) on", where, "for", "$" + tostr(cost));
this:announce_all(player:title(), " ", verb, "s ", (new == 5) ? "a hotel" |
((tostr(build) + " house") + ((build == 1) ? "" | "s")), " on ", where, " for
$", cost, ".");
.

@args #87868:"shuffle" any none none
@chmod #87868:shuffle rxd
@program #87868:shuffle
if (args)
  if (!((prop = args[1]) in {"chest", "chance"}))
    player:tell("'", prop, "' isn't 'chest' or 'chance'");
    return;
  endif
  val = {};
  for x in (this.(prop))
    val = {{random(1000), x}, @val};
  endfor
  val = $list_utils:slice($list_utils:sort_alist(val), 2);
  len = length(val);
  if (index(val[len], "get out of jail free") && valid(this.jailfree))
    "Bad luck, shuffling left that on the bottom.";
    val = {val[len], @val[1..len - 1]};
  endif
  suspend(0);
  this.(prop) = val;
  this.(prop + "_marker") = 1;
  deck = (prop == "chest") ? "Community Chest" | "Chance";
  msg = (" the deck of " + deck) + " cards.";
  player:tell("You shuffle", msg);
  this:remember(player, "shuffled", deck);
  this:announce(player.name, " shuffles", msg);
else
  for prop in ({"chest", "chance"})
    this:shuffle(prop);
  endfor
endif
.

@args #87868:"pick" any none none
@chmod #87868:pick rxd
@program #87868:pick
if (!dobjstr)
  dobjstr = this:get_floor(player);
endif
if (index(dobjstr, "chance"))
  prop = "chance";
elseif (index(dobjstr, "chest") || index(dobjstr, "comm"))
  prop = "chest";
else
  player:tell("Pick from community chest or chance!");
  return;
endif
marker = prop + "_marker";
mark = this.(marker);
msg = (" a card from the " + this.(prop + "_name")) + " pile.";
val = this.(prop)[mark];
picked = 0;
if (index(val, "get out of jail free"))
  if (valid(this.jailfree))
    "Can't have it, somebody else has it.";
    mark = mark + 1;
    if (mark > length(this.(prop)))
      val = this.(prop)[1];
    else
      val = this.(prop)[mark];
    endif
  else
    this.jailfree = player;
    picked = 1;
  endif
endif
player:tell("You pick", msg, " It says: ", val);
this:announce(player.name, " picks", msg, " It says: ", val);
this:remember(player, "picked", ("'" + val[1..min(15, length(val))]) + "...'",
"from", this.(prop + "_name"), @picked ? {"and kept it"} | {});
if (picked)
  player:tell("You keep it.");
  this:announce(player.name, " keeps it.");
endif
if ((this.(marker) = mark + 1) > length(this.(prop)))
  this:announce_all("That was the last unused card in the ", this.(prop +
"_name"), " pile.");
  suspend(0);
  this:shuffle(prop);
endif
.

@args #87868:"remove_player" this none this
@program #87868:remove_player
if (caller != this)
  return E_PERM;
elseif (!(i = args[1] in this.players))
  return E_NONE;
endif
this.riding = listdelete(this.riding, i);
this.players = listdelete(this.players, i);
this.playerlocs = listdelete(this.playerlocs, i);
return 1;
.

@args #87868:"quit concede" none none none
@chmod #87868:quit rxd
@program #87868:quit
here = this:get_floor(player);
if (this:remove_player(player))
  player:tell("You ", verb, " the Moonopoly game; you return all of your
property.");
  this:remember(player, "quit");
  this:announce_all_but({player}, player.name, " ", verb, "s the Moonopoly
game, and returns all of ", player.pp, " property.");
elseif (verb == "concede")
  player:tell("You weren't playing Moonopoly.");
endif
if (verb == "quit")
  this:exit();
else
  this:set_floor(player, here);
endif
.

@args #87868:"house_str" this none this
@program #87868:house_str
if (args[1] == 5)
  return "a hotel";
elseif (args[1] == 1)
  return "a house";
else
  return tostr(args[1]) + " houses";
endif
.

@args #87868:"reset" any any any
@chmod #87868:reset rxd
@program #87868:reset
if (argstr != "game")
  this:concede();
  return;
endif
if (this.tasks)
  player:tell("Sorry, ", this:title(), " is busy.");
  return;
endif
this:announce_all(player.name, " starts to reset the game -- type 'no' to stop
it from happening!");
this.tasks = {@this.tasks, task = {"%N %<grabs> the reset switch and %<keeps>
it from moving!", task_id()}};
suspend(10);
this.tasks = setremove(this.tasks, task);
floors = {};
init = this.initial_place;
for i in [1..length(this.houses)]
  this.houses[i] = 0;
  this.owners[i] = #-1;
  this.mortgaged[i] = 0;
endfor
this.players = {};
this.playerlocs = {};
this.riding = {};
for x in (this.contents)
  this:set_floor(x, init);
endfor
this.has = {};
this.jailfree = #-1;
this:shuffle();
this:remember(player, "reset the game");
if (contents = this.contents)
  desc = this:description(this.contents[1]);
  for x in (this.players)
    suspend(0);
    x:tell("You wind up on ", init, ".");
    x:tell_lines(desc);
    this:showwhere(0, x);
  endfor
endif
.

@args #87868:"map" none none none
@chmod #87868:map rxd
@program #87868:map
this:clean();
map = this.map;
mapplaces = this.map_places;
places = this.places;
for x in [1..length(this.players)]
  map = this:mapfix(this.playerlocs[x] in places, this.players[x].name[1], map,
0);
endfor
for x in [1..40]
  if (h = this.houses[x])
    map = this:mapfix(x, (h == 5) ? "h" | tostr(h), map, 1);
  endif
  if (valid(o = this.owners[x]))
    map = this:mapfix(x, o.name[1], map, -1);
  endif
endfor
map = this:add_dice(map);
player:tell_lines(map);
if (contents = this.contents)
  this:showwhere(2);
else
  player:tell("No one seems to be playing at the moment.");
endif
.

@args #87868:"find" this none this
@program #87868:find
where = args[1];
if ((where == "here") || (where == ""))
  return this:get_floor(player);
elseif (ind = where in this.places)
  return this.places[ind];
endif
for x in (this.places)
  if (index(x, where) == 1)
    return x;
  endif
endfor
for x in (this.places)
  if (this:matchname(where, x))
    return x;
  endif
endfor
return "";
.

@args #87868:"rent" any none none
@chmod #87868:rent rxd
@program #87868:rent
if (argstr == "all")
  places = this.places;
elseif (place = this:find(argstr))
  places = {place};
else
  player:tell("No such place: ", argstr);
  return;
endif
for place in (places)
  rent = this:rent_due(place, #-1);
  if (!rent[1])
    if (argstr != "all")
      player:tell("Nothing due: ", rent[2]);
    endif
  else
    player:tell("Landing on ", place, " costs $", rent[1], ", paid to ",
rent[2].name, ".");
  endif
endfor
.

@args #87868:"d*eed" any none none
@chmod #87868:deed rxd
@program #87868:deed
if (!(where = this:find(dobjstr)))
  player:tell("Sorry, ", dobjstr, " isn't a valid place name.");
  return;
endif
index = where in this.places;
if (!(price = this.price[index]))
  player:tell(where, " doesn't have a deed.");
  return;
endif
su = $string_utils;
color = this.color[index];
if ((typeof(own = this.owners[index]) == OBJ) && valid(own))
  player:tell("Next to ", own:title(), this.mortgaged[index] ? ", upside down,"
| "", " you see:");
else
  player:tell("In the Bank's stack, you see: ");
endif
player:tell("+-----------------------------+");
if (color)
  this:deedline(su:center(("Title deed (" + color) + ")", 29));
else
  this:deedline("");
  this:deedline("");
endif
this:deedline(su:center(su:uppercase(where), 29));
this:deedline("-----------------------------");
if (index in this.railroads)
  this:deedline("");
  this:deedline(" Rent                  $  25.");
  this:deedline(" If 2 R.R.'s are owned $  50.");
  this:deedline(" If 3  ''    ''   ''   $ 100.");
  this:deedline(" If 4  ''    ''   ''   $ 200.");
  this:deedline("");
  this:deedline("");
elseif (index in this.utilities)
  this:deedline("   If one \"Utility\" is owned");
  this:deedline(" rent is 4 times amount shown");
  this:deedline(" on dice.");
  this:deedline("   If both \"Utilities\" are");
  this:deedline(" owned rent is 10 times");
  this:deedline(" amount shown on dice.");
  this:deedline("");
elseif (color)
  house = this.housing[index];
  this:deedline(su:center(tostr("RENT $", house[2], "."), 29));
  for i in [1..4]
    this:deedline(" With ", i, " House", (i == 1) ? "         $" | "s
", su:right(house[i + 2], 4), ".");
  endfor
  this:deedline("     With HOTEL $", house[7], ".");
else
  this:deedline("Bug !!");
endif
this:deedline(" Mortgage Value $", this.price[index] / 2, ".");
if (color)
  this:deedline("  Houses cost $", house[1], ". each");
  this:deedline("Hotels, $", house[1], ". plus 4 houses");
endif
this:deedline("(c) 1935 Parker Brothers     ");
player:tell("+-----------------------------+");
.

@args #87868:"tr*ansfer" any to any
@chmod #87868:transfer rxd
@program #87868:transfer
if (dobjstr == "card")
  if (this.jailfree != player)
    player:tell("You aren't holding the Get Out Of Jail Free card.");
    return;
  elseif (!valid(recip = this:find_player(iobjstr)))
    return;
  endif
  this.jailfree = recip;
  where = "the Get Out of Jail Free card";
else
  if (!(where = this:find(dobjstr)))
    player:tell("Sorry, '", dobjstr, "' isn't a valid place name.");
    return;
  endif
  index = where in this.places;
  if (player != this.owners[index])
    player:tell("You don't own ", where, ".");
    return;
  endif
  if (!valid(recip = this:find_player(iobjstr)))
    return;
  endif
  if (this.houses[index])
    player:tell("Sorry, ", where, " still has ",
this:house_str(this.houses[index]), " on it!");
    return;
  endif
  this.owners[index] = recip;
endif
recip:tell(player.name, " transfers ", where, " to you.");
player:tell("You transfer ", where, " to ", recip.name, ".");
this:remember(player, "transfered", where, "to", recip);
this:announce_all_but({player, recip}, player.name, " transfers ", where, " to
", recip.name, ".");
.

@args #87868:"return" any any any
@chmod #87868:return rxd
@program #87868:return
if (dobjstr == "card")
  if (this.jailfree != player)
    player:tell("You don't have the GET OUT OF JAIL FREE card.");
  else
    this.jailfree = #-1;
    player:tell("You return the GET OUT OF JAIL FREE card to the middle of the
deck.");
    this:announce(player.name, " returns the GET OUT OF JAIL FREE card to the
middle of the deck.");
  endif
  return 0;
endif
if (!(where = this:find(iobjstr)))
  player:tell("There isn't any space named ", iobjstr, ".");
endif
index = where in this.places;
if (this.owners[index] != player)
  player:tell("Sorry, you don't own ", this.places[index], ".");
  return;
endif
if (!(houses = this.houses[index]))
  player:tell("Sorry, there aren't any improvements on ", where, ".");
  return;
endif
if (dobjstr == "hotel")
  if (houses != 5)
    player:tell("There isn't a hotel on ", where, ".");
    return;
  endif
  ret = 1;
elseif ((dobjstr == "all") || (dobjstr == ""))
  ret = houses;
elseif ((dobjstr == "a house") || (dobjstr == "house"))
  ret = 1;
elseif (!(ret = tonum(dobjstr)))
  player:tell(dobjstr, " doesn't seem to be a valid number.");
  return;
endif
if (ret > houses)
  player:tell("Sorry, that would result in ", houses - ret, " houses!");
  return;
endif
cost = (this.housing[index][1] * ret) / 2;
has = this.has;
playerhas = $list_utils:assoc(player, has) || {player, 0};
this.has = {{player, playerhas[2] + cost}, @setremove(has, playerhas)};
this.houses[index] = houses - ret;
this:remember(player, "returned", ret, "house(s) for $" + tostr(cost));
this:announce_all(player:title(), " ", verb, "s ", (tostr(ret) + " house") +
((ret == 1) ? "" | "s"), " on ", where, " for $", cost, ".");
.

@args #87868:"mapfix" this none this
@program #87868:mapfix
ind = args[1];
symbol = args[2];
old = args[3];
offset = args[4];
mapplaces = this.map_places;
row = mapplaces[2][ind];
col = mapplaces[1][ind];
if (offset < 0)
  if (col == 6)
    col = (col + offset) - 4;
  elseif (col == 44)
    col = (col - offset) + 4;
  elseif (row == 23)
    row = (row - offset) + 1;
  elseif (row == 3)
    row = (row + offset) - 1;
  endif
elseif (offset)
  if (col == 6)
    col = col + offset;
  elseif (col == 44)
    col = col - offset;
  elseif (row == 23)
    row = row - offset;
  elseif (row == 3)
    row = row + offset;
  endif
endif
if (!offset)
  for rm in ({0, -1, 1})
    for cm in ({0, 1, 2, -1, -2})
      if (old[row + rm][col + cm] == " ")
        row = row + rm;
        col = col + cm;
        rowlist = old[row];
        return listset(old, (rowlist[1..col - 1] + symbol) + rowlist[col +
1..length(rowlist)], row);
      endif
    endfor
  endfor
  symbol = "*";
endif
rowlist = old[row];
return listset(old, (rowlist[1..col - 1] + symbol) + rowlist[col +
1..length(rowlist)], row);
.

@args #87868:"matchname" this none this
@program #87868:matchname
abbrev = args[1];
full = args[2];
if (abbrev[1] != full[1])
  return "";
endif
if (spa = index(abbrev, " "))
  if (spb = index(full, " "))
    if (this:matchname(abbrev[1..spa - 1], full[1..spb - 1]) &&
this:matchname(abbrev[spa + 1..length(abbrev)], full[spb + 1..length(full)]))
      return full;
    endif
  endif
  return "";
endif
p = 1;
x = full;
while (w = index(x, abbrev[p]))
  if (p == length(abbrev))
    return full;
  endif
  x = x[w + 1..length(x)];
  p = p + 1;
endwhile
return "";
.

@args #87868:"find_player" this none this
@program #87868:find_player
"find player of this game with given name";
this:clean();
name = args[1];
if (name == "me")
  return player;
elseif (name)
  if (valid(dobj = $string_utils:match(name, this.players, "name")))
    return dobj;
  elseif (valid(dobj = $string_utils:match_player(name)))
    player:tell(dobj:title(), " isn't playing.");
    return #-1;
  elseif (dobj == $ambiguous_match)
    player:tell("I don't know which \"", name, "\" you mean.");
  else
    player:tell("\"", name, "\" doesn't match any current player.");
  endif
  return dobj;
endif
.

@args #87868:"showwhere" this none this
@program #87868:showwhere
this:clean();
seenrooms = {};
seenthings = {};
showtokens = 0;
notplayer = player.location == this;
who = player;
if (args)
  if (length(args) > 1)
    who = args[2];
    notplayer = who.location == this;
  endif
  if ((showtokens = args[1]) == 2)
    notplayer = 0;
  endif
endif
here = "";
for x in [1..length(this.players)]
  play = this.players[x];
  where = this.playerlocs[x];
  if ((play == who) && notplayer)
    here = where;
  else
    name = this:ptitle(play);
    if (ind = where in seenrooms)
      seenthings[ind] = listappend(seenthings[ind], name);
    else
      seenrooms = listappend(seenrooms, where);
      seenthings = listappend(seenthings, {name});
    endif
  endif
endfor
desc = {};
for i in [1..length(seenrooms)]
  msg = $string_utils:english_list(seenthings[i]) + ((length(seenthings[i]) ==
1) ? " is " | " are ");
  room = seenrooms[i];
  if (room == here)
    desc = {msg + "here", @desc};
  else
    desc = {@desc, msg + this:onroom(room, 0)};
  endif
endfor
if (desc)
  who:tell($string_utils:from_list(desc, "; "), ".");
endif
.

@args #87868:"done" none none none
@chmod #87868:done rxd
@program #87868:done
msg = {"winks", "gives a haughty flourish", "raises an eyebrow", "rubs %p hands
together greedily"};
ind = player in this.players;
if (ind && (ind = this.riding[ind]))
  msg = this.tokens[2][ind];
  msg = msg[1 + random(length(msg) - 1)];
  msg = {strsub(msg, "%t", this.tokens[1][ind])};
endif
msg = this:construct_msg({@msg, "nods", "waves"}, {" as %p turn is over", " and
finishes %p turn", ", as if to indicate %s is done with %p turn"}, ".");
this:emote(argstr = msg);
.

@args #87868:"get_contents" this none this
@program #87868:get_contents
floor = args[1];
tc = this.contents;
contents = {};
for x in (this.contents)
  if (this:get_floor(x) == floor)
    contents = listappend(contents, x);
  endif
endfor
return contents;
.

@args #87868:"add_dice" this none this
@program #87868:add_dice
map = args[1];
len = length(map[1]);
roll = this.last_roll;
die = this.die;
for dn in [1..2]
  if (len < 30)
    rn = 0;
    cn = 0 + ((dn - 1) * (len - 6));
  else
    rn = 4 + random(2);
    cn = {7, 15}[dn] + random({4, 10}[dn]);
  endif
  for row in [1..5]
    rowlist = map[rn + row];
    map[rn + row] = (rowlist[1..cn] + ((row in {1, 5}) ? " --- " | (("|" +
die[roll[dn]][row - 1]) + "|"))) + rowlist[cn + 6..len];
  endfor
endfor
return map;
.

@args #87868:"rollstat" this none this
@program #87868:rollstat
roll = this.last_roll;
player:tell(roll[3].name, " last rolled ",
$string_utils:english_number(roll[1]), " and ",
$string_utils:english_number(roll[2]), ".");
.

@args #87868:"do_move" this none this
@program #87868:do_move
oldfloor = this:get_floor(player);
oldind = oldfloor in this.places;
cnt = args[1];
advance = cnt > 0;
if (!oldind)
  player:tell("You don't seem to be anywhere on ", this.name, ".");
elseif (oldind > 40)
  player:tell("You can't move that way from ", oldfloor, ".");
  return;
elseif ((cnt > 12) || (cnt < -12))
  player:tell("You try to go ", cnt, " spaces, but decide it is too far, and
stay put.");
  return;
endif
new = this.places[(((oldind + cnt) + 39) % 40) + 1];
announce = (cnt > 0) ? "forward " | "backward ";
cnt = abs(cnt);
announce = ((((announce + tostr(cnt)) + " space") + ((cnt == 1) ? " to " | "s
to ")) + new) + ".";
this:move2(new, oldind, advance);
.

@args #87868:"worth" none none none
@chmod #87868:worth rxd
@program #87868:worth
who = args ? args[1] | player;
total = 0;
for x in (this.has)
  if (x[1] == who)
    total = total + x[2];
  endif
endfor
for x in [1..40]
  if (this.owners[x] == who)
    total = total + this.price[x];
    if (this.houses[x])
      total = total + (this.houses[x] * this.housing[x][1]);
    endif
  endif
endfor
this:announce_all(player:title(), " computes ", (player == who) ? player.pp |
(who:title() + "'s"), " net worth (for tax purposes) as $", total, ".");
return total;
.

@args #87868:"l*ook" any any any
@chmod #87868:look rxd
@program #87868:look
if (looking = (prepstr == "at") ? (!dobjstr) && iobjstr | (((!prepstr) &&
(!iobjstr)) && dobjstr))
  if (looking == "dice")
    roll = this.last_roll;
    player:tell(roll[3].name, " last rolled...");
    dx = {};
    for i in [1..5]
      dx = {@dx, "             "};
    endfor
    player:tell_lines(this:add_dice(dx));
    if (roll[1] == roll[2])
      player:tell("Doubles!");
    endif
    return;
  elseif (valid(dobj))
    pass(@args);
    if ((playeri = dobj in this.players) && (riding = this.riding[playeri]))
      player:tell($string_utils:pronoun_sub("%N is ", dobj),
this.tokens[2][riding][1], " ", this.tokens[1][riding], ".");
    endif
    return;
  elseif (prepstr && valid(iobj))
    return pass(@args);
  elseif (where = this:find(looking) || ((looking == "here") && (where =
this:get_place(player))))
    cnt = this:get_contents(where);
    here = player in cnt;
    player:tell("You look ", here ? "around" | ((("at " + where) + " of ") +
this.name), " and see...");
    player:tell_lines(this:roomdesc(where, player));
    if (cnt = setremove(cnt, player))
      player:tell($string_utils:english_list($list_utils:map_verb(cnt,
"title")), (length(cnt) == 1) ? " is" | " are", " ", here ? "here" | "there",
".");
    endif
    return;
  endif
endif
return pass(@args);
.

@args #87868:"construct_msg" this none this
@program #87868:construct_msg
msg = "";
for x in (args)
  msg = msg + ((typeof(x) == LIST) ? x[random(length(x))] | x);
endfor
return $string_utils:pronoun_sub(msg);
.

@args #87868:"roomdesc" this none this
@program #87868:roomdesc
floor = args[1];
who = args[2];
desc = "The floor is light-green shiny paper.";
index = floor in this.places;
if (!index)
  return "A place named " + ((typeof(floor) == STR) ? floor |
$string_utils:print(floor));
endif
if (floor == "Jail")
  desc = "A small square area of orange shiny paper.";
elseif (index)
  desc = ("A " + {"rectangular", "very large square", "square", "square",
"square", "odd-shaped"}[1 + (floor in {"Center", "Go", "Free Parking", "Go to
Jail", "Jail--Just Visiting"})]) + " area of light-green shiny paper.";
endif
owner = this.owners[index];
if (color = this.color[index])
  houses = this.houses[index];
  if (!houses)
    desc = desc + " You see";
  elseif (houses == 5)
    desc = desc + " You see a large red hotel on";
  elseif (houses == 1)
    desc = desc + " You see a small green house on";
  else
    desc = ((desc + " You see ") + tostr(houses)) + " small green houses on";
  endif
  desc = ((desc + " a ") + color) + " rectangle here.";
elseif (feature = this.features[index])
  desc = ((desc + " You see ") + feature) + ".";
endif
owner = this.owners[index];
if (valid(owner))
  if (who == owner)
    desc = desc + " You have the deed to this space.";
  else
    desc = ((desc + " ") + owner:title()) + " has the deed to this square.";
  endif
elseif (this.price[index])
  desc = ((desc + " On the floor, it says \"price $") +
tostr(this.price[index])) + "\".";
endif
return desc;
.

@args #87868:"ride" any none none
@chmod #87868:ride rxd
@program #87868:ride
this:clean();
tokens = this.tokens;
picked = ((!dobjstr) && iobjstr) || argstr;
if (!picked)
  player:tell("Ride an unused token... ");
  this:dostatus("token");
  return 0;
endif
if (index(argstr, "as "))
  argstr = argstr[3..length(argstr)];
endif
if (!(picked in tokens[1]))
  for x in (tokens[1])
    if (index(x, picked))
      picked = x;
    endif
  endfor
endif
ind = picked in tokens[1];
if (!ind)
  player:tell(argstr, " isn't a token of ", this.name, ".");
  this:dostatus("token");
  return 0;
endif
if (!(playeri = player in this.players))
  player:tell("You aren't playing ", this.name, ".");
  return 0;
endif
this.riding[playeri] = 0;
if (off = ind in this.riding)
  player:tell("Sorry, ", this.players[off].name, " is already using the ",
picked, ".");
  this:dostatus("token");
  return 0;
endif
this.riding[playeri] = ind;
this:announce_all(player.name, " is now ", tokens[2][ind][1], " ", picked,
".");
return 1;
.

@args #87868:"ptitle" this none this
@program #87868:ptitle
who = args[1];
here = who in this.contents;
playeri = who in this.players;
if (playeri && (riding = this.riding[playeri]))
  if (here)
    title = who:title();
    tok = this.tokens[1][riding];
    add = (this.tokens[2][riding][1] + " ") + tok;
    if (lpar = index(title, "("))
      return ((title[1..lpar] + add) + " and ") + title[lpar +
1..length(title)];
    else
      return ((title + " (") + add) + ")";
    endif
  else
    return (who.name + "'s ") + this.tokens[1][riding];
  endif
elseif (here)
  return who:title();
else
  return who.name + "'s ghost";
endif
.

@args #87868:"title" this none this
@program #87868:title
who = args ? args[1] | player;
if (!(who in this.contents))
  return pass();
endif
if (caller != this)
  c = callers();
  while (c)
    vb = c[1][2];
    if (vb == "look_self")
      c = {};
    elseif (vb in {"tell_contents", "teleport_msg", "thing_port_msg",
"thing_arrive_msg", "who_location_msg"})
      return pass();
    elseif (rindex(vb, "_msg") == (length(vb) - 3))
      who = c[1][1];
      c = {};
    else
      c = listdelete(c, 1);
    endif
  endwhile
endif
return ((floor = this:get_floor(who)) ? floor + " of " | "") + pass();
.

@args #87868:"dostatus" this none this
@program #87868:dostatus
if (args[1] == "token")
  unused = {};
  used = {};
  for i in [1..length(this.tokens[1])]
    if (ind = i in this.riding)
      used = {@used, (((this.players[ind]:title() + " is ") +
this.tokens[2][i][1]) + " ") + this.tokens[1][i]};
    else
      unused = {@unused, this.tokens[1][i]};
    endif
  endfor
  if (used)
    player:tell($string_utils:english_list(used), ".");
  endif
  if (unused)
    player:tell("The ", $string_utils:english_list(unused), " ",
(length(unused) == 1) ? "is" | "are", " unused.");
  endif
else
  player:tell("Status for ", args[1], " isn't available.");
endif
.

@args #87868:"onroom" this none this
@program #87868:onroom
room = args[1];
if (room == "Center")
  STR = "in the";
elseif (room == "Jail")
  STR = "in";
else
  STR = "on";
endif
if (args[2])
  STR = $string_utils:capitalize(STR);
endif
return (STR + " ") + room;
.

@args #87868:"history" any none none
@chmod #87868:history rxd
@program #87868:history
h = this.history;
len = min(length(h), argstr ? max(tonum(argstr), 1) | 10);
before = "";
for x in [1..len]
  msg = h[(len + 1) - x];
  z = "";
  for y in (msg)
    if (typeof(y) == STR)
      z = (z + " ") + y;
    elseif (typeof(y) == OBJ)
      z = (z + " ") + y.name;
    else
      z = (z + " ") + tostr(y);
    endif
  endfor
  player:tell(">", z, ".");
endfor
.

@args #87868:"out" none none none
@chmod #87868:out rxd
@program #87868:out
player:tell("'Go out' to get out of jail, 'exit' to leave the game temporarily,
'quit' to leave the game & return all property.");
.

@args #87868:"remember" this none this
@program #87868:remember
h = this.history;
len = length(h);
this.history = {args, @h[1..min(42, len)]};
.

@args #87868:"no" none none none
@chmod #87868:no rx
@program #87868:no
if (this.tasks)
  for x in (this.tasks)
    player:tell($string_utils:pronoun_sub(x[1], $you));
    this:announce_all_but({player}, $string_utils:pronoun_sub(x[1], player));
    kill_task(x[2]);
  endfor
  this.tasks = {};
else
  player:tell("You're probably too late, there's nothing to stop!");
endif
.

@args #87868:"deedline" this none this
@program #87868:deedline
player:tell("|", $string_utils:left(tostr(@args), 29), "|");
.

@args #87868:"find_topics" this none this
@program #87868:find_topics
topic = args[1];
res = {};
for x in (this.rules)
  if ((!topic) || index(x[1], topic))
    res = {@res, $string_utils:words(x[1])[1]};
  endif
endfor
return res;
.

@args #87868:"get_topic" this none this
@program #87868:get_topic
topic = args[1];
for x in (this.rules)
  if ((!topic) || index(x[1], topic))
    return listdelete(x, 1);
  endif
endfor
.

@args #87868:"who_location_msg" this none this
@program #87868:who_location_msg
if (args && (floor = this:get_floor(args[1])))
  return ((this.name + " (") + floor) + ")";
else
  return pass(@args);
endif
.

@args #87868:"dust" this none this
@chmod #87868:dust rd
@program #87868:dust
if (this.tasks)
  player:tell("Sorry, ", this:title(), " is busy.");
  return;
else
  this.history = {};
endif
.

@args #87868:"clean" this none this
@chown #87868:clean #2487
@program #87868:clean
for x in (this.players)
  if (!$recycler:valid(x))
    this:remove_player(x);
  endif
endfor
.

"***finished***
